
{
  "name": "S::mutate_a",
  "safe": true,
  "callees": [
    "std::string::String::new"
  ],
  "adts": {
    "std::string::String": [
      "Plain"
    ],
    "S": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": [
    "variant_idx",
    "S",
    "mutate_a"
  ],
  "span": "$DIR/variant-idx.rs:2:5: 4:6",
  "src": "fn mutate_a(&mut self) {/n        self.a = String::new();/n    }",
  "mir": "fn S::mutate_a(_1: &mut S) -> () {/n    let mut _0: ();/n    let mut _2: std::string::String;/n    debug self => _1;/n    bb0: {/n        _2 = std::string::String::new() -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        drop(((*_1).0: std::string::String)) -> [return: bb2, unwind: bb3];/n    }/n    bb2: {/n        ((*_1).0: std::string::String) = move _2;/n        return;/n    }/n    bb3: {/n        ((*_1).0: std::string::String) = move _2;/n        resume;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::mutate",
  "safe": true,
  "callees": [
    "std::string::String::new",
    "std::string::String::push"
  ],
  "adts": {
    "std::string::String": [
      "Plain",
      "MutRef"
    ],
    "S": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ]
  },
  "path": [
    "variant_idx",
    "S",
    "mutate"
  ],
  "span": "$DIR/variant-idx.rs:6:5: 9:6",
  "src": "fn mutate(&mut self) {/n        self.a = String::new();/n        self.b.push(' ');/n    }",
  "mir": "fn S::mutate(_1: &mut S) -> () {/n    let mut _0: ();/n    let mut _2: std::string::String;/n    let  _3: ();/n    let mut _4: &mut std::string::String;/n    debug self => _1;/n    bb0: {/n        _2 = std::string::String::new() -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        drop(((*_1).0: std::string::String)) -> [return: bb2, unwind: bb3];/n    }/n    bb2: {/n        ((*_1).0: std::string::String) = move _2;/n        _4 = &mut ((*_1).1: std::string::String);/n        _3 = std::string::String::push(move _4, ' ') -> [return: bb4, unwind continue];/n    }/n    bb3: {/n        ((*_1).0: std::string::String) = move _2;/n        resume;/n    }/n    bb4: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "E::mutate1",
  "safe": true,
  "callees": [
    "std::string::String::push"
  ],
  "adts": {
    "E": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1, kind: RigidTy(Adt(AdtDef(DefId { id: 6, name: /"std::string::String/" }), GenericArgs([]))) })])",
      "MutRef"
    ],
    "std::string::String": [
      "MutRef"
    ]
  },
  "path": [
    "variant_idx",
    "E",
    "mutate1"
  ],
  "span": "$DIR/variant-idx.rs:13:5: 17:6",
  "src": "fn mutate1(&mut self) {/n        if let E::A(a) = self {/n            a.push(' ');/n        }/n    }",
  "mir": "fn E::mutate1(_1: &mut E) -> () {/n    let mut _0: ();/n    let mut _2: isize;/n    let  _3: &mut std::string::String;/n    let  _4: ();/n    debug self => _1;/n    debug a => _3;/n    bb0: {/n        _2 = discriminant((*_1));/n        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb3];/n    }/n    bb1: {/n        _3 = &mut (((*_1) as variant#0).0: std::string::String);/n        _4 = std::string::String::push(_3, ' ') -> [return: bb2, unwind continue];/n    }/n    bb2: {/n        return;/n    }/n    bb3: {/n        unreachable;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "E::mutate2",
  "safe": true,
  "callees": [
    "std::string::String::push",
    "std::string::String::new"
  ],
  "adts": {
    "E": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1, kind: RigidTy(Adt(AdtDef(DefId { id: 6, name: /"std::string::String/" }), GenericArgs([]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1, kind: RigidTy(Adt(AdtDef(DefId { id: 6, name: /"std::string::String/" }), GenericArgs([]))) })])",
      "MutRef"
    ],
    "std::string::String": [
      "MutRef",
      "Plain",
      "Deref"
    ]
  },
  "path": [
    "variant_idx",
    "E",
    "mutate2"
  ],
  "span": "$DIR/variant-idx.rs:19:5: 24:6",
  "src": "fn mutate2(&mut self) {/n        match self {/n            E::A(a) => *a = String::new(),/n            E::B(b) => b.push(' '),/n        };/n    }",
  "mir": "fn E::mutate2(_1: &mut E) -> () {/n    let mut _0: ();/n    let  _2: ();/n    let mut _3: isize;/n    let  _4: &mut std::string::String;/n    let mut _5: std::string::String;/n    let  _6: &mut std::string::String;/n    debug self => _1;/n    debug a => _4;/n    debug b => _6;/n    bb0: {/n        _3 = discriminant((*_1));/n        switchInt(move _3) -> [0: bb3, 1: bb2, otherwise: bb1];/n    }/n    bb1: {/n        unreachable;/n    }/n    bb2: {/n        _6 = &mut (((*_1) as variant#1).0: std::string::String);/n        _2 = std::string::String::push(_6, ' ') -> [return: bb7, unwind continue];/n    }/n    bb3: {/n        _4 = &mut (((*_1) as variant#0).0: std::string::String);/n        _5 = std::string::String::new() -> [return: bb4, unwind continue];/n    }/n    bb4: {/n        drop((*_4)) -> [return: bb5, unwind: bb6];/n    }/n    bb5: {/n        (*_4) = move _5;/n        goto -> bb7;/n    }/n    bb6: {/n        (*_4) = move _5;/n        resume;/n    }/n    bb7: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "E::mutate_plain",
  "safe": true,
  "callees": [
    "std::string::String::new"
  ],
  "adts": {
    "E": [
      "Deref",
      "Plain",
      "MutRef"
    ],
    "std::string::String": [
      "Plain"
    ]
  },
  "path": [
    "variant_idx",
    "E",
    "mutate_plain"
  ],
  "span": "$DIR/variant-idx.rs:26:5: 31:6",
  "src": "fn mutate_plain(&mut self) {/n        *self = match self {/n            E::A(_) => E::A(String::new()),/n            E::B(_) => E::B(String::new()),/n        };/n    }",
  "mir": "fn E::mutate_plain(_1: &mut E) -> () {/n    let mut _0: ();/n    let mut _2: E;/n    let mut _3: isize;/n    let mut _4: std::string::String;/n    let mut _5: std::string::String;/n    debug self => _1;/n    bb0: {/n        _3 = discriminant((*_1));/n        switchInt(move _3) -> [0: bb3, 1: bb2, otherwise: bb1];/n    }/n    bb1: {/n        unreachable;/n    }/n    bb2: {/n        _5 = std::string::String::new() -> [return: bb5, unwind continue];/n    }/n    bb3: {/n        _4 = std::string::String::new() -> [return: bb4, unwind continue];/n    }/n    bb4: {/n        _2 = E::A(move _4);/n        goto -> bb6;/n    }/n    bb5: {/n        _2 = E::B(move _5);/n        goto -> bb6;/n    }/n    bb6: {/n        drop((*_1)) -> [return: bb7, unwind: bb8];/n    }/n    bb7: {/n        (*_1) = move _2;/n        return;/n    }/n    bb8: {/n        (*_1) = move _2;/n        resume;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "std::string::String",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "S::mutate",
      "E::mutate1",
      "E::mutate2",
      "E::mutate2"
    ],
    "other": [
      "S::mutate_a",
      "S::mutate",
      "E::mutate2",
      "E::mutate_plain"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/string.rs:353:1: 353:18",
  "src": "pub struct String",
  "kind": "Struct",
  "doc_adt": " A UTF-8â€“encoded, growable string./n/n `String` is the most common string type. It has ownership over the contents/n of the string, stored in a heap-allocated buffer (see [Representation](#representation))./n It is closely related to its borrowed counterpart, the primitive [`str`]./n/n # Examples/n/n You can create a `String` from [a literal string][`&str`] with [`String::from`]:/n/n [`String::from`]: From::from/n/n ```/n let hello = String::from(/"Hello, world!/");/n ```/n/n You can append a [`char`] to a `String` with the [`push`] method, and/n append a [`&str`] with the [`push_str`] method:/n/n ```/n let mut hello = String::from(/"Hello, /");/n/n hello.push('w');/n hello.push_str(/"orld!/");/n ```/n/n [`push`]: String::push/n [`push_str`]: String::push_str/n/n If you have a vector of UTF-8 bytes, you can create a `String` from it with/n the [`from_utf8`] method:/n/n ```/n // some bytes, in a vector/n let sparkle_heart = vec![240, 159, 146, 150];/n/n // We know these bytes are valid, so we'll use `unwrap()`./n let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();/n/n assert_eq!(/"ðŸ’–/", sparkle_heart);/n ```/n/n [`from_utf8`]: String::from_utf8/n/n # UTF-8/n/n `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider/n [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8/n is a variable width encoding, `String`s are typically smaller than an array of/n the same `char`s:/n/n ```/n // `s` is ASCII which represents each `char` as one byte/n let s = /"hello/";/n assert_eq!(s.len(), 5);/n/n // A `char` array with the same contents would be longer because/n // every `char` is four bytes/n let s = ['h', 'e', 'l', 'l', 'o'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n/n // However, for non-ASCII strings, the difference will be smaller/n // and sometimes they are the same/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.len(), 20);/n/n let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n ```/n/n This raises interesting questions as to how `s[i]` should work./n What should `i` be here? Several options include byte indices and/n `char` indices but, because of UTF-8 encoding, only byte indices/n would provide constant time indexing. Getting the `i`th `char`, for/n example, is available using [`chars`]:/n/n ```/n let s = /"hello/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('l'));/n/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('ðŸ’–'));/n ```/n/n Next, what should `s[i]` return? Because indexing returns a reference/n to underlying data it could be `&u8`, `&[u8]`, or something similar./n Since we're only providing one index, `&u8` makes the most sense but that/n might not be what the user expects and can be explicitly achieved with/n [`as_bytes()`]:/n/n ```/n // The first byte is 104 - the byte value of `'h'`/n let s = /"hello/";/n assert_eq!(s.as_bytes()[0], 104);/n // or/n assert_eq!(s.as_bytes()[0], b'h');/n/n // The first byte is 240 which isn't obviously useful/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.as_bytes()[0], 240);/n ```/n/n Due to these ambiguities/restrictions, indexing with a `usize` is simply/n forbidden:/n/n ```compile_fail,E0277/n let s = /"hello/";/n/n // The following will not compile!/n println!(/"The first letter of s is {}/", s[0]);/n ```/n/n It is more clear, however, how `&s[i..j]` should work (that is,/n indexing with a range). It should accept byte indices (to be constant-time)/n and return a `&str` which is UTF-8 encoded. This is also called /"string slicing/"./n Note this will panic if the byte indices provided are not character/n boundaries - see [`is_char_boundary`] for more details. See the implementations/n for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking/n version of string slicing, see [`get`]./n/n [`OsString`]: ../../std/ffi/struct.OsString.html /"ffi::OsString/"/n [`SliceIndex<str>`]: core::slice::SliceIndex/n [`as_bytes()`]: str::as_bytes/n [`get`]: str::get/n [`is_char_boundary`]: str::is_char_boundary/n/n The [`bytes`] and [`chars`] methods return iterators over the bytes and/n codepoints of the string, respectively. To iterate over codepoints along/n with byte indices, use [`char_indices`]./n/n [`bytes`]: str::bytes/n [`chars`]: str::chars/n [`char_indices`]: str::char_indices/n/n # Deref/n/n `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s/n methods. In addition, this means that you can pass a `String` to a/n function which takes a [`&str`] by using an ampersand (`&`):/n/n ```/n fn takes_str(s: &str) { }/n/n let s = String::from(/"Hello/");/n/n takes_str(&s);/n ```/n/n This will create a [`&str`] from the `String` and pass it in. This/n conversion is very inexpensive, and so generally, functions will accept/n [`&str`]s as arguments unless they need a `String` for some specific/n reason./n/n In certain cases Rust doesn't have enough information to make this/n conversion, known as [`Deref`] coercion. In the following example a string/n slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function/n `example_func` takes anything that implements the trait. In this case Rust/n would need to make two implicit conversions, which Rust doesn't have the/n means to do. For that reason, the following example will not compile./n/n ```compile_fail,E0277/n trait TraitExample {}/n/n impl<'a> TraitExample for &'a str {}/n/n fn example_func<A: TraitExample>(example_arg: A) {}/n/n let example_string = String::from(/"example_string/");/n example_func(&example_string);/n ```/n/n There are two options that would work instead. The first would be to/n change the line `example_func(&example_string);` to/n `example_func(example_string.as_str());`, using the method [`as_str()`]/n to explicitly extract the string slice containing the string. The second/n way changes `example_func(&example_string);` to/n `example_func(&*example_string);`. In this case we are dereferencing a/n `String` to a [`str`], then referencing the [`str`] back to/n [`&str`]. The second way is more idiomatic, however both work to do the/n conversion explicitly rather than relying on the implicit conversion./n/n # Representation/n/n A `String` is made up of three components: a pointer to some bytes, a/n length, and a capacity. The pointer points to the internal buffer which `String`/n uses to store its data. The length is the number of bytes currently stored/n in the buffer, and the capacity is the size of the buffer in bytes. As such,/n the length will always be less than or equal to the capacity./n/n This buffer is always stored on the heap./n/n You can look at these with the [`as_ptr`], [`len`], and [`capacity`]/n methods:/n/n ```/n let story = String::from(/"Once upon a time.../");/n/n // Deconstruct the String into parts./n let (ptr, len, capacity) = story.into_raw_parts();/n/n // story has nineteen bytes/n assert_eq!(19, len);/n/n // We can re-build a String out of ptr, len, and capacity. This is all/n // unsafe because we are responsible for making sure the components are/n // valid:/n let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;/n/n assert_eq!(String::from(/"Once upon a time.../"), s);/n ```/n/n [`as_ptr`]: str::as_ptr/n [`len`]: String::len/n [`capacity`]: String::capacity/n/n If a `String` has enough capacity, adding elements to it will not/n re-allocate. For example, consider this program:/n/n ```/n let mut s = String::new();/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n This will output the following:/n/n ```text/n 0/n 8/n 16/n 16/n 32/n 32/n ```/n/n At first, we have no memory allocated at all, but as we append to the/n string, it increases its capacity appropriately. If we instead use the/n [`with_capacity`] method to allocate the correct capacity initially:/n/n ```/n let mut s = String::with_capacity(25);/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n [`with_capacity`]: String::with_capacity/n/n We end up with a different output:/n/n ```text/n 25/n 25/n 25/n 25/n 25/n 25/n ```/n/n Here, there's no need to allocate more memory inside the loop./n/n [str]: prim@str /"str/"/n [`str`]: prim@str /"str/"/n [`&str`]: prim@str /"&str/"/n [Deref]: core::ops::Deref /"ops::Deref/"/n [`Deref`]: core::ops::Deref /"ops::Deref/"/n [`as_str()`]: String::as_str/n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "vec",
      "doc": ""
    }
  }
}

{
  "name": "S",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [
      "S::mutate_a",
      "S::mutate"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "S::mutate_a",
        "S::mutate"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "S::mutate"
      ],
      "other": []
    }
  ],
  "span": "$DIR/variant-idx.rs:35:1: 35:9",
  "src": "struct S",
  "kind": "Struct",
  "doc_adt": " Struct S doc./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "a",
      "doc": " Field a doc./n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "b",
      "doc": " Field b doc./n"
    }
  }
}

{
  "name": "E",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [
      "E::mutate1",
      "E::mutate2",
      "E::mutate_plain",
      "E::mutate1",
      "E::mutate2",
      "E::mutate_plain"
    ],
    "other": [
      "E::mutate1",
      "E::mutate2",
      "E::mutate2",
      "E::mutate_plain"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [],
  "span": "$DIR/variant-idx.rs:43:1: 43:7",
  "src": "enum E",
  "kind": "Enum",
  "doc_adt": " Enum doc./n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "A",
      "doc": " Varaint A doc./n"
    },
    "VariantIdx(Some(0))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "B",
      "doc": " Varaint B doc./n"
    },
    "VariantIdx(Some(1))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}

{
  "data": [
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Struct",
        "name": "S"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "mutate"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "mutate_a"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Enum",
        "name": "E"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Enum",
        "name": "E"
      },
      {
        "kind": "AssocFn",
        "name": "mutate1"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Enum",
        "name": "E"
      },
      {
        "kind": "AssocFn",
        "name": "mutate2"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "variant_idx"
      },
      {
        "kind": "Enum",
        "name": "E"
      },
      {
        "kind": "AssocFn",
        "name": "mutate_plain"
      }
    ]
  ],
  "navi": {
    "0": [
      1,
      4
    ],
    "1": [
      2,
      3
    ],
    "4": [
      5,
      6,
      7
    ]
  },
  "name_to_path": {
    "variant_idx::S::mutate_a": 3,
    "variant_idx::S::mutate": 2,
    "variant_idx::E::mutate1": 5,
    "variant_idx::E::mutate2": 6,
    "variant_idx::E::mutate_plain": 7,
    "variant_idx::S": 1,
    "variant_idx::E": 4
  }
}
