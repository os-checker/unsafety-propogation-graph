
{
  "name": "S::new",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Plain"
    ],
    "std::string::String": [
      "Plain"
    ]
  },
  "path": 4,
  "span": "$DIR/struct-methods.rs:13:5: 15:6",
  "src": "fn new(s: String) -> S {/n        S { s }/n    }",
  "mir": "fn S::new(_1: std::string::String) -> S {/n    let mut _0: S;/n    debug s => _1;/n    bb0: {/n        _0 = S(_1);/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::s_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Ref"
    ]
  },
  "path": 6,
  "span": "$DIR/struct-methods.rs:17:5: 17:23",
  "src": "fn s_ref(&self) {}",
  "mir": "fn S::s_ref(_1: &S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::s_mut_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "MutRef"
    ]
  },
  "path": 5,
  "span": "$DIR/struct-methods.rs:19:5: 19:31",
  "src": "fn s_mut_ref(&mut self) {}",
  "mir": "fn S::s_mut_ref(_1: &mut S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::field_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "Ref"
    ]
  },
  "path": 3,
  "span": "$DIR/struct-methods.rs:21:5: 23:6",
  "src": "fn field_ref(&self) {/n        _ = &self.s;/n    }",
  "mir": "fn S::field_ref(_1: &S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::field_mut_ref",
  "safe": true,
  "callees": [],
  "adts": {
    "S": [
      "MutRef"
    ]
  },
  "path": 2,
  "span": "$DIR/struct-methods.rs:25:5: 27:6",
  "src": "fn field_mut_ref(&mut self) {/n        _ = &mut self.s;/n    }",
  "mir": "fn S::field_mut_ref(_1: &mut S) -> () {/n    let mut _0: ();/n    debug self => _1;/n    bb0: {/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S::write_field",
  "safe": true,
  "callees": [
    "std::string::String::new"
  ],
  "adts": {
    "std::string::String": [
      "Plain"
    ],
    "S": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 7,
  "span": "$DIR/struct-methods.rs:30:5: 32:6",
  "src": "fn write_field(&mut self) {/n        self.s = String::new();/n    }",
  "mir": "fn S::write_field(_1: &mut S) -> () {/n    let mut _0: ();/n    let mut _2: std::string::String;/n    debug self => _1;/n    bb0: {/n        _2 = std::string::String::new() -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        drop(((*_1).0: std::string::String)) -> [return: bb2, unwind: bb3];/n    }/n    bb2: {/n        ((*_1).0: std::string::String) = move _2;/n        return;/n    }/n    bb3: {/n        ((*_1).0: std::string::String) = move _2;/n        resume;/n    }/n}/n",
  "doc": " Update the field./n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "S",
  "constructors": [
    "S::new"
  ],
  "access_self_as_arg": {
    "read": [
      "S::s_ref",
      "S::field_ref"
    ],
    "write": [
      "S::s_mut_ref",
      "S::field_mut_ref",
      "S::write_field"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "S::new"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "S::write_field"
      ],
      "other": []
    }
  ],
  "span": "$DIR/struct-methods.rs:7:1: 7:9",
  "src": "struct S",
  "kind": "Struct",
  "doc_adt": " First line./n Second line./n/n Forth line./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "s",
      "doc": " Field comments./n"
    }
  }
}

{
  "name": "std::string::String",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "S::new"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "S::write_field"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/string.rs:353:1: 353:18",
  "src": "pub struct String",
  "kind": "Struct",
  "doc_adt": " A UTF-8â€“encoded, growable string./n/n `String` is the most common string type. It has ownership over the contents/n of the string, stored in a heap-allocated buffer (see [Representation](#representation))./n It is closely related to its borrowed counterpart, the primitive [`str`]./n/n # Examples/n/n You can create a `String` from [a literal string][`&str`] with [`String::from`]:/n/n [`String::from`]: From::from/n/n ```/n let hello = String::from(/"Hello, world!/");/n ```/n/n You can append a [`char`] to a `String` with the [`push`] method, and/n append a [`&str`] with the [`push_str`] method:/n/n ```/n let mut hello = String::from(/"Hello, /");/n/n hello.push('w');/n hello.push_str(/"orld!/");/n ```/n/n [`push`]: String::push/n [`push_str`]: String::push_str/n/n If you have a vector of UTF-8 bytes, you can create a `String` from it with/n the [`from_utf8`] method:/n/n ```/n // some bytes, in a vector/n let sparkle_heart = vec![240, 159, 146, 150];/n/n // We know these bytes are valid, so we'll use `unwrap()`./n let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();/n/n assert_eq!(/"ðŸ’–/", sparkle_heart);/n ```/n/n [`from_utf8`]: String::from_utf8/n/n # UTF-8/n/n `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider/n [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8/n is a variable width encoding, `String`s are typically smaller than an array of/n the same `char`s:/n/n ```/n // `s` is ASCII which represents each `char` as one byte/n let s = /"hello/";/n assert_eq!(s.len(), 5);/n/n // A `char` array with the same contents would be longer because/n // every `char` is four bytes/n let s = ['h', 'e', 'l', 'l', 'o'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n/n // However, for non-ASCII strings, the difference will be smaller/n // and sometimes they are the same/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.len(), 20);/n/n let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n ```/n/n This raises interesting questions as to how `s[i]` should work./n What should `i` be here? Several options include byte indices and/n `char` indices but, because of UTF-8 encoding, only byte indices/n would provide constant time indexing. Getting the `i`th `char`, for/n example, is available using [`chars`]:/n/n ```/n let s = /"hello/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('l'));/n/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('ðŸ’–'));/n ```/n/n Next, what should `s[i]` return? Because indexing returns a reference/n to underlying data it could be `&u8`, `&[u8]`, or something similar./n Since we're only providing one index, `&u8` makes the most sense but that/n might not be what the user expects and can be explicitly achieved with/n [`as_bytes()`]:/n/n ```/n // The first byte is 104 - the byte value of `'h'`/n let s = /"hello/";/n assert_eq!(s.as_bytes()[0], 104);/n // or/n assert_eq!(s.as_bytes()[0], b'h');/n/n // The first byte is 240 which isn't obviously useful/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.as_bytes()[0], 240);/n ```/n/n Due to these ambiguities/restrictions, indexing with a `usize` is simply/n forbidden:/n/n ```compile_fail,E0277/n let s = /"hello/";/n/n // The following will not compile!/n println!(/"The first letter of s is {}/", s[0]);/n ```/n/n It is more clear, however, how `&s[i..j]` should work (that is,/n indexing with a range). It should accept byte indices (to be constant-time)/n and return a `&str` which is UTF-8 encoded. This is also called /"string slicing/"./n Note this will panic if the byte indices provided are not character/n boundaries - see [`is_char_boundary`] for more details. See the implementations/n for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking/n version of string slicing, see [`get`]./n/n [`OsString`]: ../../std/ffi/struct.OsString.html /"ffi::OsString/"/n [`SliceIndex<str>`]: core::slice::SliceIndex/n [`as_bytes()`]: str::as_bytes/n [`get`]: str::get/n [`is_char_boundary`]: str::is_char_boundary/n/n The [`bytes`] and [`chars`] methods return iterators over the bytes and/n codepoints of the string, respectively. To iterate over codepoints along/n with byte indices, use [`char_indices`]./n/n [`bytes`]: str::bytes/n [`chars`]: str::chars/n [`char_indices`]: str::char_indices/n/n # Deref/n/n `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s/n methods. In addition, this means that you can pass a `String` to a/n function which takes a [`&str`] by using an ampersand (`&`):/n/n ```/n fn takes_str(s: &str) { }/n/n let s = String::from(/"Hello/");/n/n takes_str(&s);/n ```/n/n This will create a [`&str`] from the `String` and pass it in. This/n conversion is very inexpensive, and so generally, functions will accept/n [`&str`]s as arguments unless they need a `String` for some specific/n reason./n/n In certain cases Rust doesn't have enough information to make this/n conversion, known as [`Deref`] coercion. In the following example a string/n slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function/n `example_func` takes anything that implements the trait. In this case Rust/n would need to make two implicit conversions, which Rust doesn't have the/n means to do. For that reason, the following example will not compile./n/n ```compile_fail,E0277/n trait TraitExample {}/n/n impl<'a> TraitExample for &'a str {}/n/n fn example_func<A: TraitExample>(example_arg: A) {}/n/n let example_string = String::from(/"example_string/");/n example_func(&example_string);/n ```/n/n There are two options that would work instead. The first would be to/n change the line `example_func(&example_string);` to/n `example_func(example_string.as_str());`, using the method [`as_str()`]/n to explicitly extract the string slice containing the string. The second/n way changes `example_func(&example_string);` to/n `example_func(&*example_string);`. In this case we are dereferencing a/n `String` to a [`str`], then referencing the [`str`] back to/n [`&str`]. The second way is more idiomatic, however both work to do the/n conversion explicitly rather than relying on the implicit conversion./n/n # Representation/n/n A `String` is made up of three components: a pointer to some bytes, a/n length, and a capacity. The pointer points to the internal buffer which `String`/n uses to store its data. The length is the number of bytes currently stored/n in the buffer, and the capacity is the size of the buffer in bytes. As such,/n the length will always be less than or equal to the capacity./n/n This buffer is always stored on the heap./n/n You can look at these with the [`as_ptr`], [`len`], and [`capacity`]/n methods:/n/n ```/n let story = String::from(/"Once upon a time.../");/n/n // Deconstruct the String into parts./n let (ptr, len, capacity) = story.into_raw_parts();/n/n // story has nineteen bytes/n assert_eq!(19, len);/n/n // We can re-build a String out of ptr, len, and capacity. This is all/n // unsafe because we are responsible for making sure the components are/n // valid:/n let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;/n/n assert_eq!(String::from(/"Once upon a time.../"), s);/n ```/n/n [`as_ptr`]: str::as_ptr/n [`len`]: String::len/n [`capacity`]: String::capacity/n/n If a `String` has enough capacity, adding elements to it will not/n re-allocate. For example, consider this program:/n/n ```/n let mut s = String::new();/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n This will output the following:/n/n ```text/n 0/n 8/n 16/n 16/n 32/n 32/n ```/n/n At first, we have no memory allocated at all, but as we append to the/n string, it increases its capacity appropriately. If we instead use the/n [`with_capacity`] method to allocate the correct capacity initially:/n/n ```/n let mut s = String::with_capacity(25);/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n [`with_capacity`]: String::with_capacity/n/n We end up with a different output:/n/n ```text/n 25/n 25/n 25/n 25/n 25/n 25/n ```/n/n Here, there's no need to allocate more memory inside the loop./n/n [str]: prim@str /"str/"/n [`str`]: prim@str /"str/"/n [`&str`]: prim@str /"&str/"/n [Deref]: core::ops::Deref /"ops::Deref/"/n [`Deref`]: core::ops::Deref /"ops::Deref/"/n [`as_str()`]: String::as_str/n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "vec",
      "doc": ""
    }
  }
}

{
  "data": [
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "field_mut_ref"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "field_ref"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "new"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "s_mut_ref"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "s_ref"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "struct_methods"
      },
      {
        "kind": "Struct",
        "name": "S"
      },
      {
        "kind": "AssocFn",
        "name": "write_field"
      }
    ]
  ],
  "navi": {
    "0": [
      {
        "idx": 1,
        "name": "S",
        "kind": "Struct"
      }
    ],
    "1": [
      {
        "idx": 2,
        "name": "field_mut_ref",
        "kind": "AssocFn"
      },
      {
        "idx": 3,
        "name": "field_ref",
        "kind": "AssocFn"
      },
      {
        "idx": 4,
        "name": "new",
        "kind": "AssocFn"
      },
      {
        "idx": 5,
        "name": "s_mut_ref",
        "kind": "AssocFn"
      },
      {
        "idx": 6,
        "name": "s_ref",
        "kind": "AssocFn"
      },
      {
        "idx": 7,
        "name": "write_field",
        "kind": "AssocFn"
      }
    ]
  },
  "name_to_path": {
    "struct_methods::S": 1,
    "struct_methods::S::new": 4,
    "struct_methods::S::s_ref": 6,
    "struct_methods::S::s_mut_ref": 5,
    "struct_methods::S::field_ref": 3,
    "struct_methods::S::field_mut_ref": 2,
    "struct_methods::S::write_field": 7
  },
  "path_to_name": {
    "1": "struct_methods::S",
    "4": "struct_methods::S::new",
    "6": "struct_methods::S::s_ref",
    "5": "struct_methods::S::s_mut_ref",
    "3": "struct_methods::S::field_ref",
    "2": "struct_methods::S::field_mut_ref",
    "7": "struct_methods::S::write_field"
  }
}
