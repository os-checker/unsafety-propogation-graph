
{
  "name": "f",
  "safe": true,
  "callees": [
    "alloc::alloc::exchange_malloc",
    "std::vec::Vec::<u32>::into_raw_parts",
    "SecretRegion::from",
    "SecretRegion::set_len",
    "core::slice::<impl [u32]>::as_mut_ptr",
    "SecretRegion::xor_secret_region",
    "std::slice::<impl [u32]>::into_vec::<std::alloc::Global>"
  ],
  "adts": {
    "std::ptr::NonNull[[u32; 3]]": [
      "Plain"
    ],
    "std::ptr::Unique[[u32; 3]]": [
      "Plain"
    ],
    "std::boxed::Box[[u32; 3], std::alloc::Global]": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6, kind: RigidTy(Adt(AdtDef(DefId { id: 7, name: /"std::ptr::Unique/" }), GenericArgs([Type(Ty { id: 1, kind: RigidTy(Array(Ty { id: 10, kind: RigidTy(Uint(U32)) }, TyConst { kind: Value(Ty { id: 2, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(3), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(0, ThreadLocalIndex) })) })]))) }), Field(0, Ty { id: 7, kind: RigidTy(Adt(AdtDef(DefId { id: 6, name: /"std::ptr::NonNull/" }), GenericArgs([Type(Ty { id: 1, kind: RigidTy(Array(Ty { id: 10, kind: RigidTy(Uint(U32)) }, TyConst { kind: Value(Ty { id: 2, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(3), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(0, ThreadLocalIndex) })) })]))) })])"
    ],
    "std::vec::Vec[u32, std::alloc::Global]": [
      "Plain"
    ],
    "SecretRegion": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "std::boxed::Box[[u32], std::alloc::Global]": [
      "Plain"
    ]
  },
  "path": 1,
  "span": "$DIR/poc.rs:33:1: 42:2",
  "src": "fn f() {/n    let v = vec![0xDEADBEEFu32, 0xCAFEBABE, 0x12345678];/n    let mut data = [0x11111111u32, 0x22222222, 0x33333333];/n    let (p, l, _c) = v.into_raw_parts();/n    let mut s = unsafe { SecretRegion::from(p, 0) };/n    unsafe {/n        s.set_len(l);/n        s.xor_secret_region(data.as_mut_ptr(), 0);/n    }/n}",
  "mir": "fn f() -> () {/n    let mut _0: ();/n    let  _1: std::vec::Vec<u32>;/n    let mut _2: std::boxed::Box<[u32]>;/n    let mut _3: *mut u8;/n    let mut _4: std::boxed::Box<[u32; 3]>;/n    let mut _5: [u32; 3];/n    let  _6: *mut u32;/n    let  _7: usize;/n    let  _8: usize;/n    let mut _9: (*mut u32, usize, usize);/n    let mut _10: SecretRegion;/n    let  _11: ();/n    let mut _12: &mut SecretRegion;/n    let  _13: u32;/n    let mut _14: &SecretRegion;/n    let mut _15: *mut u32;/n    let mut _16: &mut [u32];/n    let mut _17: &mut [u32; 3];/n    let mut _18: *const [u32; 3];/n    let mut _19: std::ptr::NonNull<[u32; 3]>;/n    let mut _20: std::ptr::Unique<[u32; 3]>;/n    let mut _21: *const [u32; 3];/n    let mut _22: *const ();/n    let mut _23: usize;/n    let mut _24: usize;/n    let mut _25: usize;/n    let mut _26: bool;/n    let mut _27: *const ();/n    let mut _28: usize;/n    let mut _29: bool;/n    let mut _30: bool;/n    let mut _31: bool;/n    let mut _32: bool;/n    debug v => _1;/n    debug data => _5;/n    debug p => _6;/n    debug l => _7;/n    debug _c => _8;/n    debug s => _10;/n    bb0: {/n        _3 = alloc::alloc::exchange_malloc(<[u32; 3] as std::mem::SizedTypeProperties>::SIZE, <[u32; 3] as std::mem::SizedTypeProperties>::ALIGN) -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        _18 = move _3 as *const [u32; 3];/n        _19 = NonNull(move _18);/n        _20 = Unique(move _19, std::marker::PhantomData::<[u32; 3]>);/n        _4 = Box(move _20, std::alloc::Global);/n        _21 = ((_4.0: std::ptr::Unique<[u32; 3]>).0: std::ptr::NonNull<[u32; 3]>) as *const [u32; 3];/n        _22 = _21 as *const ();/n        _23 = _22 as usize;/n        _24 = Sub(<[u32; 3] as std::mem::SizedTypeProperties>::ALIGN, 1_usize);/n        _25 = BitAnd(_23, _24);/n        _26 = Eq(_25, 0_usize);/n        assert(_26, /"misaligned pointer dereference: address must be a multiple of {} but is {}/",<[u32; 3] as std::mem::SizedTypeProperties>::ALIGN, _23) -> [success: bb8, unwind unreachable];/n    }/n    bb2: {/n        _5 = [286331153_u32, 572662306_u32, 858993459_u32];/n        _9 = std::vec::Vec::<u32>::into_raw_parts(_1) -> [return: bb3, unwind continue];/n    }/n    bb3: {/n        _6 = (_9.0: *mut u32);/n        _7 = (_9.1: usize);/n        _8 = (_9.2: usize);/n        _10 = SecretRegion::from(_6, 0_usize) -> [return: bb4, unwind continue];/n    }/n    bb4: {/n        _12 = &mut _10;/n        _11 = SecretRegion::set_len(move _12, _7) -> [return: bb5, unwind continue];/n    }/n    bb5: {/n        _14 = &_10;/n        _17 = &mut _5;/n        _16 = move _17 as &mut [u32];/n        _15 = core::slice::<impl [u32]>::as_mut_ptr(move _16) -> [return: bb6, unwind continue];/n    }/n    bb6: {/n        _13 = SecretRegion::xor_secret_region(move _14, move _15, 0_isize) -> [return: bb7, unwind continue];/n    }/n    bb7: {/n        return;/n    }/n    bb8: {/n        _27 = _21 as *const ();/n        _28 = _27 as usize;/n        _29 = Ne(<[u32; 3] as std::mem::SizedTypeProperties>::SIZE, 0_usize);/n        _30 = Eq(_28, 0_usize);/n        _31 = BitAnd(_30, _29);/n        _32 = Not(_31);/n        assert(_32, /"null pointer dereference occurred/") -> [success: bb9, unwind unreachable];/n    }/n    bb9: {/n        (*_21) = [3735928559_u32, 3405691582_u32, 305419896_u32];/n        _2 = _4 as std::boxed::Box<[u32]>;/n        _1 = std::slice::<impl [u32]>::into_vec::<std::alloc::Global>(move _2) -> [return: bb2, unwind continue];/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "SecretRegion::from",
  "safe": false,
  "callees": [],
  "adts": {
    "SecretRegion": [
      "Plain"
    ]
  },
  "path": 3,
  "span": "$DIR/poc.rs:13:5: 15:6",
  "src": "pub unsafe fn from(v: *mut u32, l: usize) -> Self {/n        SecretRegion { buffer: v, len: l }/n    }",
  "mir": "fn SecretRegion::from(_1: *mut u32, _2: usize) -> SecretRegion {/n    let mut _0: SecretRegion;/n    debug v => _1;/n    debug l => _2;/n    bb0: {/n        _0 = SecretRegion(_1, _2);/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "ValidPtr"
        },
        "args": [
          "v"
        ]
      },
      {
        "tag": {
          "typ": null,
          "name": "InitializedInLen"
        },
        "args": [
          "l"
        ]
      }
    ],
    "spec": {},
    "docs": [
      "* ValidPtr/n* InitializedInLen/n"
    ]
  }
}

{
  "name": "SecretRegion::set_len",
  "safe": false,
  "callees": [],
  "adts": {
    "SecretRegion": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ]
  },
  "path": 4,
  "span": "$DIR/poc.rs:18:5: 20:6",
  "src": "pub unsafe fn set_len(&mut self, l: usize) {/n        self.len = l;/n    }",
  "mir": "fn SecretRegion::set_len(_1: &mut SecretRegion, _2: usize) -> () {/n    let mut _0: ();/n    debug self => _1;/n    debug l => _2;/n    bb0: {/n        ((*_1).1: usize) = _2;/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": "hazard",
          "name": "InitializedInLen"
        },
        "args": [
          "l"
        ]
      }
    ],
    "spec": {},
    "docs": [
      "* InitializedInLen/n"
    ]
  }
}

{
  "name": "SecretRegion::xor_secret_region",
  "safe": false,
  "callees": [
    "std::ptr::mut_ptr::<impl *mut u32>::read",
    "std::ptr::mut_ptr::<impl *mut u32>::offset"
  ],
  "adts": {
    "SecretRegion": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 5,
  "span": "$DIR/poc.rs:23:5: 30:6",
  "src": "pub unsafe fn xor_secret_region(&self, ptr: *mut u32, offset: isize) -> u32 {/n        let mut src_value = ptr.read();/n        let secret_ptr = self.buffer;/n        let secret_region_ptr = secret_ptr.offset(offset);/n        let secret_value = secret_region_ptr.read();/n        src_value ^= secret_value;/n        src_value/n    }",
  "mir": "fn SecretRegion::xor_secret_region(_1: &SecretRegion, _2: *mut u32, _3: isize) -> u32 {/n    let mut _0: u32;/n    let mut _4: u32;/n    let  _5: *mut u32;/n    let  _6: *mut u32;/n    let  _7: u32;/n    debug self => _1;/n    debug ptr => _2;/n    debug offset => _3;/n    debug src_value => _4;/n    debug secret_ptr => _5;/n    debug secret_region_ptr => _6;/n    debug secret_value => _7;/n    bb0: {/n        _4 = std::ptr::mut_ptr::<impl *mut u32>::read(_2) -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        _5 = ((*_1).0: *mut u32);/n        _6 = std::ptr::mut_ptr::<impl *mut u32>::offset(_5, _3) -> [return: bb2, unwind continue];/n    }/n    bb2: {/n        _7 = std::ptr::mut_ptr::<impl *mut u32>::read(_6) -> [return: bb3, unwind continue];/n    }/n    bb3: {/n        _4 = BitXor(_4, _7);/n        _0 = _4;/n        return;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "ValidPtr"
        },
        "args": [
          "ptr"
        ]
      },
      {
        "tag": {
          "typ": null,
          "name": "ValidPtr"
        },
        "args": [
          "self . buffer",
          "offset"
        ]
      }
    ],
    "spec": {},
    "docs": [
      "* ValidPtr/n* ValidPtr/n"
    ]
  }
}

{
  "name": "std::ptr::NonNull[[u32; 3]]",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/core/src/ptr/non_null.rs:76:1: 76:36",
  "src": "pub struct NonNull<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " `*mut T` but non-zero and [covariant]./n/n This is often the correct thing to use when building data structures using/n raw pointers, but is ultimately more dangerous to use because of its additional/n properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!/n/n Unlike `*mut T`, the pointer must always be non-null, even if the pointer/n is never dereferenced. This is so that enums may use this forbidden value/n as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`./n However the pointer may still dangle if it isn't dereferenced./n/n Unlike `*mut T`, `NonNull<T>` is covariant over `T`. This is usually the correct/n choice for most data structures and safe abstractions, such as `Box`, `Rc`, `Arc`, `Vec`,/n and `LinkedList`./n/n In rare cases, if your type exposes a way to mutate the value of `T` through a `NonNull<T>`,/n and you need to prevent unsoundness from variance (for example, if `T` could be a reference/n with a shorter lifetime), you should add a field to make your type invariant, such as/n `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`./n/n Example of a type that must be invariant:/n ```rust/n use std::cell::Cell;/n use std::marker::PhantomData;/n struct Invariant<T> {/n     ptr: std::ptr::NonNull<T>,/n     _invariant: PhantomData<Cell<T>>,/n }/n ```/n/n Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does/n not change the fact that mutating through a (pointer derived from a) shared/n reference is undefined behavior unless the mutation happens inside an/n [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared/n reference. When using this `From` instance without an `UnsafeCell<T>`,/n it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`/n is never used for mutation./n/n # Representation/n/n Thanks to the [null pointer optimization],/n `NonNull<T>` and `Option<NonNull<T>>`/n are guaranteed to have the same size and alignment:/n/n ```/n use std::ptr::NonNull;/n/n assert_eq!(size_of::<NonNull<i16>>(), size_of::<Option<NonNull<i16>>>());/n assert_eq!(align_of::<NonNull<i16>>(), align_of::<Option<NonNull<i16>>>());/n/n assert_eq!(size_of::<NonNull<str>>(), size_of::<Option<NonNull<str>>>());/n assert_eq!(align_of::<NonNull<str>>(), align_of::<Option<NonNull<str>>>());/n ```/n/n [covariant]: https://doc.rust-lang.org/reference/subtyping.html/n [`PhantomData`]: crate::marker::PhantomData/n [`UnsafeCell<T>`]: crate::cell::UnsafeCell/n [null pointer optimization]: crate::option#representation/n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    }
  }
}

{
  "name": "std::ptr::Unique[[u32; 3]]",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/core/src/ptr/unique.rs:36:1: 36:35",
  "src": "pub struct Unique<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " A wrapper around a raw non-null `*mut T` that indicates that the possessor/n of this wrapper owns the referent. Useful for building abstractions like/n `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`./n/n Unlike `*mut T`, `Unique<T>` behaves /"as if/" it were an instance of `T`./n It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies/n the kind of strong aliasing guarantees an instance of `T` can expect:/n the referent of the pointer should not be modified without a unique path to/n its owning Unique./n/n If you're uncertain of whether it's correct to use `Unique` for your purposes,/n consider using `NonNull`, which has weaker semantics./n/n Unlike `*mut T`, the pointer must always be non-null, even if the pointer/n is never dereferenced. This is so that enums may use this forbidden value/n as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`./n However the pointer may still dangle if it isn't dereferenced./n/n Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct/n for any type which upholds Unique's aliasing requirements./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    }
  }
}

{
  "name": "std::boxed::Box[[u32; 3], std::alloc::Global]",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f",
      "f"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/boxed.rs:234:1: 237:2",
  "src": "pub struct Box</n    T: ?Sized,/n    #[unstable(feature = /"allocator_api/", issue = /"32838/")] A: Allocator = Global,/n>",
  "kind": "Struct",
  "doc_adt": " A pointer type that uniquely owns a heap allocation of type `T`./n/n See the [module-level documentation](../../std/boxed/index.html) for more./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "1",
      "doc": ""
    }
  }
}

{
  "name": "std::vec::Vec[u32, std::alloc::Global]",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/vec/mod.rs:438:1: 438:97",
  "src": "pub struct Vec<T, #[unstable(feature = /"allocator_api/", issue = /"32838/")] A: Allocator = Global>",
  "kind": "Struct",
  "doc_adt": " A contiguous growable array type, written as `Vec<T>`, short for 'vector'./n/n # Examples/n/n ```/n let mut vec = Vec::new();/n vec.push(1);/n vec.push(2);/n/n assert_eq!(vec.len(), 2);/n assert_eq!(vec[0], 1);/n/n assert_eq!(vec.pop(), Some(2));/n assert_eq!(vec.len(), 1);/n/n vec[0] = 7;/n assert_eq!(vec[0], 7);/n/n vec.extend([1, 2, 3]);/n/n for x in &vec {/n     println!(/"{x}/");/n }/n assert_eq!(vec, [7, 1, 2, 3]);/n ```/n/n The [`vec!`] macro is provided for convenient initialization:/n/n ```/n let mut vec1 = vec![1, 2, 3];/n vec1.push(4);/n let vec2 = Vec::from([1, 2, 3, 4]);/n assert_eq!(vec1, vec2);/n ```/n/n It can also initialize each element of a `Vec<T>` with a given value./n This may be more efficient than performing allocation and initialization/n in separate steps, especially when initializing a vector of zeros:/n/n ```/n let vec = vec![0; 5];/n assert_eq!(vec, [0, 0, 0, 0, 0]);/n/n // The following is equivalent, but potentially slower:/n let mut vec = Vec::with_capacity(5);/n vec.resize(5, 0);/n assert_eq!(vec, [0, 0, 0, 0, 0]);/n ```/n/n For more information, see/n [Capacity and Reallocation](#capacity-and-reallocation)./n/n Use a `Vec<T>` as an efficient stack:/n/n ```/n let mut stack = Vec::new();/n/n stack.push(1);/n stack.push(2);/n stack.push(3);/n/n while let Some(top) = stack.pop() {/n     // Prints 3, 2, 1/n     println!(/"{top}/");/n }/n ```/n/n # Indexing/n/n The `Vec` type allows access to values by index, because it implements the/n [`Index`] trait. An example will be more explicit:/n/n ```/n let v = vec![0, 2, 4, 6];/n println!(/"{}/", v[1]); // it will display '2'/n ```/n/n However be careful: if you try to access an index which isn't in the `Vec`,/n your software will panic! You cannot do this:/n/n ```should_panic/n let v = vec![0, 2, 4, 6];/n println!(/"{}/", v[6]); // it will panic!/n ```/n/n Use [`get`] and [`get_mut`] if you want to check whether the index is in/n the `Vec`./n/n # Slicing/n/n A `Vec` can be mutable. On the other hand, slices are read-only objects./n To get a [slice][prim@slice], use [`&`]. Example:/n/n ```/n fn read_slice(slice: &[usize]) {/n     // .../n }/n/n let v = vec![0, 1];/n read_slice(&v);/n/n // ... and that's all!/n // you can also do it like this:/n let u: &[usize] = &v;/n // or like this:/n let u: &[_] = &v;/n ```/n/n In Rust, it's more common to pass slices as arguments rather than vectors/n when you just want to provide read access. The same goes for [`String`] and/n [`&str`]./n/n # Capacity and reallocation/n/n The capacity of a vector is the amount of space allocated for any future/n elements that will be added onto the vector. This is not to be confused with/n the *length* of a vector, which specifies the number of actual elements/n within the vector. If a vector's length exceeds its capacity, its capacity/n will automatically be increased, but its elements will have to be/n reallocated./n/n For example, a vector with capacity 10 and length 0 would be an empty vector/n with space for 10 more elements. Pushing 10 or fewer elements onto the/n vector will not change its capacity or cause reallocation to occur. However,/n if the vector's length is increased to 11, it will have to reallocate, which/n can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]/n whenever possible to specify how big the vector is expected to get./n/n # Guarantees/n/n Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees/n about its design. This ensures that it's as low-overhead as possible in/n the general case, and can be correctly manipulated in primitive ways/n by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`./n If additional type parameters are added (e.g., to support custom allocators),/n overriding their defaults may change the behavior./n/n Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)/n triplet. No more, no less. The order of these fields is completely/n unspecified, and you should use the appropriate methods to modify these./n The pointer will never be null, so this type is null-pointer-optimized./n/n However, the pointer might not actually point to allocated memory. In particular,/n if you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],/n [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]/n on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized/n types inside a `Vec`, it will not allocate space for them. *Note that in this case/n the `Vec` might not report a [`capacity`] of 0*. `Vec` will allocate if and only/n if <code>[size_of::/<T>]/() * [capacity]/() > 0</code>. In general, `Vec`'s allocation/n details are very subtle --- if you intend to allocate memory using a `Vec`/n and use it for something else (either to pass to unsafe code, or to build your/n own memory-backed collection), be sure to deallocate this memory by using/n `from_raw_parts` to recover the `Vec` and then dropping it./n/n If a `Vec` *has* allocated memory, then the memory it points to is on the heap/n (as defined by the allocator Rust is configured to use by default), and its/n pointer points to [`len`] initialized, contiguous elements in order (what/n you would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code>/n logically uninitialized, contiguous elements./n/n A vector containing the elements `'a'` and `'b'` with capacity 4 can be/n visualized as below. The top part is the `Vec` struct, it contains a/n pointer to the head of the allocation in the heap, length and capacity./n The bottom part is the allocation on the heap, a contiguous memory block./n/n ```text/n             ptr      len  capacity/n        +--------+--------+--------+/n        | 0x0123 |      2 |      4 |/n        +--------+--------+--------+/n             |/n             v/n Heap   +--------+--------+--------+--------+/n        |    'a' |    'b' | uninit | uninit |/n        +--------+--------+--------+--------+/n ```/n/n - **uninit** represents memory that is not initialized, see [`MaybeUninit`]./n - Note: the ABI is not stable and `Vec` makes no guarantees about its memory/n   layout (including the order of fields)./n/n `Vec` will never perform a /"small optimization/" where elements are actually/n stored on the stack for two reasons:/n/n * It would make it more difficult for unsafe code to correctly manipulate/n   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were/n   only moved, and it would be more difficult to determine if a `Vec` had/n   actually allocated memory./n/n * It would penalize the general case, incurring an additional branch/n   on every access./n/n `Vec` will never automatically shrink itself, even if completely empty. This/n ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`/n and then filling it back up to the same [`len`] should incur no calls to/n the allocator. If you wish to free up unused memory, use/n [`shrink_to_fit`] or [`shrink_to`]./n/n [`push`] and [`insert`] will never (re)allocate if the reported capacity is/n sufficient. [`push`] and [`insert`] *will* (re)allocate if/n <code>[len] == [capacity]</code>. That is, the reported capacity is completely/n accurate, and can be relied on. It can even be used to manually free the memory/n allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even/n when not necessary./n/n `Vec` does not guarantee any particular growth strategy when reallocating/n when full, nor when [`reserve`] is called. The current strategy is basic/n and it may prove desirable to use a non-constant growth factor. Whatever/n strategy is used will of course guarantee *O*(1) amortized [`push`]./n/n It is guaranteed, in order to respect the intentions of the programmer, that/n all of `vec![e_1, e_2, ..., e_n]`, `vec![x; n]`, and [`Vec::with_capacity(n)`] produce a `Vec`/n that requests an allocation of the exact size needed for precisely `n` elements from the allocator,/n and no other size (such as, for example: a size rounded up to the nearest power of 2)./n The allocator will return an allocation that is at least as large as requested, but it may be larger./n/n It is guaranteed that the [`Vec::capacity`] method returns a value that is at least the requested capacity/n and not more than the allocated capacity./n/n The method [`Vec::shrink_to_fit`] will attempt to discard excess capacity an allocator has given to a `Vec`./n If <code>[len] == [capacity]</code>, then a `Vec<T>` can be converted/n to and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements./n `Vec` exploits this fact as much as reasonable when implementing common conversions/n such as [`into_boxed_slice`]./n/n `Vec` will not specifically overwrite any data that is removed from it,/n but also won't specifically preserve it. Its uninitialized memory is/n scratch space that it may use however it wants. It will generally just do/n whatever is most efficient or otherwise easy to implement. Do not rely on/n removed data to be erased for security purposes. Even if you drop a `Vec`, its/n buffer may simply be reused by another allocation. Even if you zero a `Vec`'s memory/n first, that might not actually happen because the optimizer does not consider/n this a side-effect that must be preserved. There is one case which we will/n not break, however: using `unsafe` code to write to the excess capacity,/n and then increasing the length to match, is always valid./n/n Currently, `Vec` does not guarantee the order in which elements are dropped./n The order has changed in the past and may change again./n/n [`get`]: slice::get/n [`get_mut`]: slice::get_mut/n [`String`]: crate::string::String/n [`&str`]: type@str/n [`shrink_to_fit`]: Vec::shrink_to_fit/n [`shrink_to`]: Vec::shrink_to/n [capacity]: Vec::capacity/n [`capacity`]: Vec::capacity/n [`Vec::capacity`]: Vec::capacity/n [size_of::/<T>]: size_of/n [len]: Vec::len/n [`len`]: Vec::len/n [`push`]: Vec::push/n [`insert`]: Vec::insert/n [`reserve`]: Vec::reserve/n [`Vec::with_capacity(n)`]: Vec::with_capacity/n [`MaybeUninit`]: core::mem::MaybeUninit/n [owned slice]: Box/n [`into_boxed_slice`]: Vec::into_boxed_slice/n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "buf",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "len",
      "doc": ""
    }
  }
}

{
  "name": "SecretRegion",
  "constructors": [
    "SecretRegion::from"
  ],
  "access_self_as_arg": {
    "read": [
      "SecretRegion::xor_secret_region"
    ],
    "write": [
      "SecretRegion::set_len"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "f"
    ],
    "write": [
      "f"
    ],
    "other": [
      "f",
      "SecretRegion::from"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "SecretRegion::xor_secret_region"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "SecretRegion::set_len"
      ],
      "other": []
    }
  ],
  "span": "$DIR/poc.rs:6:1: 6:20",
  "src": "struct SecretRegion",
  "kind": "Struct",
  "doc_adt": " Record secret buffer with its size./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "buffer",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "len",
      "doc": ""
    }
  }
}

{
  "name": "std::boxed::Box[[u32], std::alloc::Global]",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/boxed.rs:234:1: 237:2",
  "src": "pub struct Box</n    T: ?Sized,/n    #[unstable(feature = /"allocator_api/", issue = /"32838/")] A: Allocator = Global,/n>",
  "kind": "Struct",
  "doc_adt": " A pointer type that uniquely owns a heap allocation of type `T`./n/n See the [module-level documentation](../../std/boxed/index.html) for more./n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "1",
      "doc": ""
    }
  }
}

{
  "data": [
    [
      {
        "kind": "Mod",
        "name": "poc"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "poc"
      },
      {
        "kind": "Fn",
        "name": "f"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "poc"
      },
      {
        "kind": "Struct",
        "name": "SecretRegion"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "poc"
      },
      {
        "kind": "Struct",
        "name": "SecretRegion"
      },
      {
        "kind": "AssocFn",
        "name": "from"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "poc"
      },
      {
        "kind": "Struct",
        "name": "SecretRegion"
      },
      {
        "kind": "AssocFn",
        "name": "set_len"
      }
    ],
    [
      {
        "kind": "Mod",
        "name": "poc"
      },
      {
        "kind": "Struct",
        "name": "SecretRegion"
      },
      {
        "kind": "AssocFn",
        "name": "xor_secret_region"
      }
    ]
  ],
  "navi": {
    "0": [
      {
        "idx": 1,
        "name": "f",
        "kind": "Fn"
      },
      {
        "idx": 2,
        "name": "SecretRegion",
        "kind": "Struct"
      }
    ],
    "2": [
      {
        "idx": 3,
        "name": "from",
        "kind": "AssocFn"
      },
      {
        "idx": 4,
        "name": "set_len",
        "kind": "AssocFn"
      },
      {
        "idx": 5,
        "name": "xor_secret_region",
        "kind": "AssocFn"
      }
    ]
  },
  "name_to_path": {
    "poc::SecretRegion": 2,
    "poc::SecretRegion::from": 3,
    "poc::SecretRegion::set_len": 4,
    "poc::SecretRegion::xor_secret_region": 5,
    "poc::f": 1
  },
  "path_to_name": {
    "2": "poc::SecretRegion",
    "3": "poc::SecretRegion::from",
    "4": "poc::SecretRegion::set_len",
    "5": "poc::SecretRegion::xor_secret_region",
    "1": "poc::f"
  }
}
