
{
  "name": "main",
  "safe": true,
  "callees": [
    "std::string::String::new"
  ],
  "adts": {
    "std::string::String": [
      "Plain"
    ],
    "S": [
      "Plain"
    ],
    "E": [
      "Plain"
    ]
  },
  "span": "$DIR/plain-places.rs:1:1: 8:2",
  "src": "fn main() {/n    let s = S {/n        a: String::new(),/n        b: String::new(),/n    };/n    let ea = E::A(String::new());/n    let eb = E::B(String::new());/n}",
  "mir": "fn main() -> () {/n    let mut _0: ();/n    let  _1: S;/n    let mut _2: std::string::String;/n    let mut _3: std::string::String;/n    let  _4: E;/n    let mut _5: std::string::String;/n    let  _6: E;/n    let mut _7: std::string::String;/n    debug s => _1;/n    debug ea => _4;/n    debug eb => _6;/n    bb0: {/n        _2 = std::string::String::new() -> [return: bb1, unwind continue];/n    }/n    bb1: {/n        _3 = std::string::String::new() -> [return: bb2, unwind: bb10];/n    }/n    bb2: {/n        _1 = S(move _2, move _3);/n        _5 = std::string::String::new() -> [return: bb3, unwind: bb9];/n    }/n    bb3: {/n        _4 = E::A(move _5);/n        _7 = std::string::String::new() -> [return: bb4, unwind: bb8];/n    }/n    bb4: {/n        _6 = E::B(move _7);/n        drop(_6) -> [return: bb5, unwind: bb8];/n    }/n    bb5: {/n        drop(_4) -> [return: bb6, unwind: bb9];/n    }/n    bb6: {/n        drop(_1) -> [return: bb7, unwind continue];/n    }/n    bb7: {/n        return;/n    }/n    bb8: {/n        drop(_4) -> [return: bb9, unwind terminate];/n    }/n    bb9: {/n        drop(_1) -> [return: bb11, unwind terminate];/n    }/n    bb10: {/n        drop(_2) -> [return: bb11, unwind terminate];/n    }/n    bb11: {/n        resume;/n    }/n}/n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}

{
  "name": "std::string::String",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "main"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$SYSROOT/alloc/src/string.rs:353:1: 353:18",
  "src": "pub struct String",
  "kind": "Struct",
  "doc_adt": " A UTF-8â€“encoded, growable string./n/n `String` is the most common string type. It has ownership over the contents/n of the string, stored in a heap-allocated buffer (see [Representation](#representation))./n It is closely related to its borrowed counterpart, the primitive [`str`]./n/n # Examples/n/n You can create a `String` from [a literal string][`&str`] with [`String::from`]:/n/n [`String::from`]: From::from/n/n ```/n let hello = String::from(/"Hello, world!/");/n ```/n/n You can append a [`char`] to a `String` with the [`push`] method, and/n append a [`&str`] with the [`push_str`] method:/n/n ```/n let mut hello = String::from(/"Hello, /");/n/n hello.push('w');/n hello.push_str(/"orld!/");/n ```/n/n [`push`]: String::push/n [`push_str`]: String::push_str/n/n If you have a vector of UTF-8 bytes, you can create a `String` from it with/n the [`from_utf8`] method:/n/n ```/n // some bytes, in a vector/n let sparkle_heart = vec![240, 159, 146, 150];/n/n // We know these bytes are valid, so we'll use `unwrap()`./n let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();/n/n assert_eq!(/"ðŸ’–/", sparkle_heart);/n ```/n/n [`from_utf8`]: String::from_utf8/n/n # UTF-8/n/n `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider/n [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8/n is a variable width encoding, `String`s are typically smaller than an array of/n the same `char`s:/n/n ```/n // `s` is ASCII which represents each `char` as one byte/n let s = /"hello/";/n assert_eq!(s.len(), 5);/n/n // A `char` array with the same contents would be longer because/n // every `char` is four bytes/n let s = ['h', 'e', 'l', 'l', 'o'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n/n // However, for non-ASCII strings, the difference will be smaller/n // and sometimes they are the same/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.len(), 20);/n/n let s = ['ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–', 'ðŸ’–'];/n let size: usize = s.into_iter().map(|c| size_of_val(&c)).sum();/n assert_eq!(size, 20);/n ```/n/n This raises interesting questions as to how `s[i]` should work./n What should `i` be here? Several options include byte indices and/n `char` indices but, because of UTF-8 encoding, only byte indices/n would provide constant time indexing. Getting the `i`th `char`, for/n example, is available using [`chars`]:/n/n ```/n let s = /"hello/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('l'));/n/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n let third_character = s.chars().nth(2);/n assert_eq!(third_character, Some('ðŸ’–'));/n ```/n/n Next, what should `s[i]` return? Because indexing returns a reference/n to underlying data it could be `&u8`, `&[u8]`, or something similar./n Since we're only providing one index, `&u8` makes the most sense but that/n might not be what the user expects and can be explicitly achieved with/n [`as_bytes()`]:/n/n ```/n // The first byte is 104 - the byte value of `'h'`/n let s = /"hello/";/n assert_eq!(s.as_bytes()[0], 104);/n // or/n assert_eq!(s.as_bytes()[0], b'h');/n/n // The first byte is 240 which isn't obviously useful/n let s = /"ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–/";/n assert_eq!(s.as_bytes()[0], 240);/n ```/n/n Due to these ambiguities/restrictions, indexing with a `usize` is simply/n forbidden:/n/n ```compile_fail,E0277/n let s = /"hello/";/n/n // The following will not compile!/n println!(/"The first letter of s is {}/", s[0]);/n ```/n/n It is more clear, however, how `&s[i..j]` should work (that is,/n indexing with a range). It should accept byte indices (to be constant-time)/n and return a `&str` which is UTF-8 encoded. This is also called /"string slicing/"./n Note this will panic if the byte indices provided are not character/n boundaries - see [`is_char_boundary`] for more details. See the implementations/n for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking/n version of string slicing, see [`get`]./n/n [`OsString`]: ../../std/ffi/struct.OsString.html /"ffi::OsString/"/n [`SliceIndex<str>`]: core::slice::SliceIndex/n [`as_bytes()`]: str::as_bytes/n [`get`]: str::get/n [`is_char_boundary`]: str::is_char_boundary/n/n The [`bytes`] and [`chars`] methods return iterators over the bytes and/n codepoints of the string, respectively. To iterate over codepoints along/n with byte indices, use [`char_indices`]./n/n [`bytes`]: str::bytes/n [`chars`]: str::chars/n [`char_indices`]: str::char_indices/n/n # Deref/n/n `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s/n methods. In addition, this means that you can pass a `String` to a/n function which takes a [`&str`] by using an ampersand (`&`):/n/n ```/n fn takes_str(s: &str) { }/n/n let s = String::from(/"Hello/");/n/n takes_str(&s);/n ```/n/n This will create a [`&str`] from the `String` and pass it in. This/n conversion is very inexpensive, and so generally, functions will accept/n [`&str`]s as arguments unless they need a `String` for some specific/n reason./n/n In certain cases Rust doesn't have enough information to make this/n conversion, known as [`Deref`] coercion. In the following example a string/n slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function/n `example_func` takes anything that implements the trait. In this case Rust/n would need to make two implicit conversions, which Rust doesn't have the/n means to do. For that reason, the following example will not compile./n/n ```compile_fail,E0277/n trait TraitExample {}/n/n impl<'a> TraitExample for &'a str {}/n/n fn example_func<A: TraitExample>(example_arg: A) {}/n/n let example_string = String::from(/"example_string/");/n example_func(&example_string);/n ```/n/n There are two options that would work instead. The first would be to/n change the line `example_func(&example_string);` to/n `example_func(example_string.as_str());`, using the method [`as_str()`]/n to explicitly extract the string slice containing the string. The second/n way changes `example_func(&example_string);` to/n `example_func(&*example_string);`. In this case we are dereferencing a/n `String` to a [`str`], then referencing the [`str`] back to/n [`&str`]. The second way is more idiomatic, however both work to do the/n conversion explicitly rather than relying on the implicit conversion./n/n # Representation/n/n A `String` is made up of three components: a pointer to some bytes, a/n length, and a capacity. The pointer points to the internal buffer which `String`/n uses to store its data. The length is the number of bytes currently stored/n in the buffer, and the capacity is the size of the buffer in bytes. As such,/n the length will always be less than or equal to the capacity./n/n This buffer is always stored on the heap./n/n You can look at these with the [`as_ptr`], [`len`], and [`capacity`]/n methods:/n/n ```/n let story = String::from(/"Once upon a time.../");/n/n // Deconstruct the String into parts./n let (ptr, len, capacity) = story.into_raw_parts();/n/n // story has nineteen bytes/n assert_eq!(19, len);/n/n // We can re-build a String out of ptr, len, and capacity. This is all/n // unsafe because we are responsible for making sure the components are/n // valid:/n let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;/n/n assert_eq!(String::from(/"Once upon a time.../"), s);/n ```/n/n [`as_ptr`]: str::as_ptr/n [`len`]: String::len/n [`capacity`]: String::capacity/n/n If a `String` has enough capacity, adding elements to it will not/n re-allocate. For example, consider this program:/n/n ```/n let mut s = String::new();/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n This will output the following:/n/n ```text/n 0/n 8/n 16/n 16/n 32/n 32/n ```/n/n At first, we have no memory allocated at all, but as we append to the/n string, it increases its capacity appropriately. If we instead use the/n [`with_capacity`] method to allocate the correct capacity initially:/n/n ```/n let mut s = String::with_capacity(25);/n/n println!(/"{}/", s.capacity());/n/n for _ in 0..5 {/n     s.push_str(/"hello/");/n     println!(/"{}/", s.capacity());/n }/n ```/n/n [`with_capacity`]: String::with_capacity/n/n We end up with a different output:/n/n ```text/n 25/n 25/n 25/n 25/n 25/n 25/n ```/n/n Here, there's no need to allocate more memory inside the loop./n/n [str]: prim@str /"str/"/n [`str`]: prim@str /"str/"/n [`&str`]: prim@str /"&str/"/n [Deref]: core::ops::Deref /"ops::Deref/"/n [`Deref`]: core::ops::Deref /"ops::Deref/"/n [`as_str()`]: String::as_str/n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "vec",
      "doc": ""
    }
  }
}

{
  "name": "S",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "main"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$DIR/plain-places.rs:10:1: 10:9",
  "src": "struct S",
  "kind": "Struct",
  "doc_adt": "",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "a",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "b",
      "doc": ""
    }
  }
}

{
  "name": "E",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "main"
    ]
  },
  "access_field": [],
  "span": "$DIR/plain-places.rs:15:1: 15:7",
  "src": "enum E",
  "kind": "Enum",
  "doc_adt": "",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "A",
      "doc": ""
    },
    "VariantIdx(Some(0))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "B",
      "doc": ""
    },
    "VariantIdx(Some(1))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}
